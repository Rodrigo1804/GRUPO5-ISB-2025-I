# -*- coding: utf-8 -*-
"""Proyecto_ISB_Wen_Extensor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dOU46zQoryq6FLCOva0KeYSaB2f9S_tB
"""

!pip install PyWavelets ipympl

import numpy as np
import matplotlib.pyplot as plt
import pywt
import pandas as pd

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np


# Función para convertir de ADC a milivoltios (mV)
def ADCtomV(ADC, n=10, VCC=3.3):
    volts = (((ADC / (2 ** n)) - (1 / 2)) * VCC) / 1009
    return volts * 1000  # Convertir a milivoltios

# Columnas
columnas = ["Tiempo", "0.1", "0.2", "0.3", "0.4", "EMG"]
fs = 1000

# Procesamiento general
def procesar_emg_csv(nombre_archivo):
    df = pd.read_csv(nombre_archivo, header=None, names=columnas)
    df = df[pd.to_numeric(df["EMG"], errors="coerce").notnull()].copy()
    df["EMG"] = pd.to_numeric(df["EMG"], errors="coerce")
    df["Tiempo"] = np.arange(len(df)) / fs
    df["EMG_mV"] = ADCtomV(df["EMG"])
    return df

# Procesar cada señal
df_Wen_Reposo_Extensor = procesar_emg_csv("Wen_Reposo_Extensor.csv")
df_Wen_Moderado_Extensor = procesar_emg_csv("Wen_Moderado_Extensor.csv")
df_Wen_Intenso_Extensor = procesar_emg_csv("Wen_Intenso_Extensor.csv")

# Mostrar como en la imagen
print("Wen_Reposo_Extensor:")
print(df_Wen_Reposo_Extensor[["Tiempo", "0.1", "0.2", "0.3", "0.4", "EMG", "EMG_mV"]].head(), "\n")

print("Wen_Moderado_Extensor:")
print(df_Wen_Moderado_Extensor[["Tiempo", "0.1", "0.2", "0.3", "0.4", "EMG", "EMG_mV"]].head(), "\n")

print("Wen_Intenso_Extensor:")
print(df_Wen_Intenso_Extensor[["Tiempo", "0.1", "0.2", "0.3", "0.4", "EMG", "EMG_mV"]].head())

df_Wen_Reposo_Extensor.plot(x="Tiempo", y="EMG_mV")
df_Wen_Moderado_Extensor.plot(x="Tiempo", y="EMG_mV")
df_Wen_Intenso_Extensor.plot(x="Tiempo", y="EMG_mV")

"""# Filtrado por DWT"""

# Señal y descomposición DWT ya definidas para extensor Wen reposo
sig = df_Wen_Reposo_Extensor["EMG_mV"].to_numpy()
wavelet = 'sym4'
level = 10
coeffs_df_Wen_Reposo_Extensor = pywt.wavedec(sig, wavelet, level=level)

# Número total de muestras
N = len(sig)

# Calcular umbrales adaptativos por nivel (D10, D9, ..., D1)
umbrales_df_Wen_Reposo_Extensor = []
for j in range(1, level + 1):
    detail_coeffs = coeffs_df_Wen_Reposo_Extensor[-j]  # D1 está al final, D10 al inicio de los detalles
    sigma = np.median(np.abs(detail_coeffs)) / 0.6745
    lambda_j = (sigma * np.sqrt(2 * np.log(N))) / np.log(j + 1)
    umbrales_df_Wen_Reposo_Extensor.insert(0, lambda_j)  # para mantener el orden: D10 → D1

# 4. Función de umbralización mejorada (artículo, ecuación 8)

def funcion_umbral_mejorada(x, lmbda, mu=0.91, delta=0.01):
    x = np.asarray(x)
    res = np.zeros_like(x)

    # |x| <= λ → 0
    mask_zero = np.abs(x) <= lmbda
    res[mask_zero] = 0

    # x > λ
    mask_pos = x > lmbda
    x_pos = x[mask_pos]
    term1 = np.exp(delta * (lmbda - x_pos)) * (lmbda**2) / np.sqrt(x_pos**2 - 2 * x_pos * np.exp(mu) * (np.exp(lmbda - x_pos) - 1))
    term2 = (1 - np.exp(delta * (lmbda - x_pos))) * (lmbda**2) / (x_pos * np.exp(delta * (x_pos - lmbda)))
    res[mask_pos] = x_pos - (term1 + term2)

    # x < -λ
    mask_neg = x < -lmbda
    x_neg = x[mask_neg]
    term1 = np.exp(delta * (lmbda + x_neg)) * (lmbda**2) / np.sqrt(x_neg**2 + 2 * x_neg * np.exp(mu) * (np.exp(lmbda + x_neg) - 1))
    term2 = (1 - np.exp(delta * (lmbda + x_neg))) * (lmbda**2) / (-x_neg * np.exp(-delta * (x_neg + lmbda)))
    res[mask_neg] = x_neg + (term1 - term2)

    return res

# -------------------------------
# 5. Aplicar umbral mejorado a cada nivel de detalle

coeffs_filtrados = [coeffs_df_Wen_Reposo_Extensor[0]]  # mantener aproximación A10

for i, c in enumerate(pywt.wavedec(sig, wavelet, level=level)):
    plt.figure()
    plt.plot(c)
    plt.title(f"Coeficientes del nivel {i} - {'A' if i==0 else 'D'+str(len(coeffs_filtrados)-i)}")

t = df_Wen_Reposo_Extensor["Tiempo"].to_numpy()
for i in range(1, level + 1):  # i = 1 → D10, ..., i = 10 → D1
    d = coeffs_df_Wen_Reposo_Extensor[i]
    lmbda = umbrales_df_Wen_Reposo_Extensor[i - 1]
    d_filtrado = funcion_umbral_mejorada(d, lmbda)
    coeffs_filtrados.append(d_filtrado)

# -------------------------------
# 6. Reconstrucción de la señal filtrada
sig_filtrada = pywt.waverec(coeffs_filtrados, wavelet)

# -------------------------------
# 7. Gráfico comparativo
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(t[:len(sig)], sig, color='blue')
plt.title('Wen Reposo Extensor - Señal EMG Original')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], color='green')
plt.title('Wen Reposo Extensor - Señal EMG Filtrada (Umbral Mejorado)')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(t[:len(sig)], sig, label='Original', alpha=0.7)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], label='Filtrada', alpha=0.7)
plt.title('Wen Reposo Extensor - Superposición')
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# Señal y descomposición DWT para Wen Moderado Extensor
sig = df_Wen_Moderado_Extensor["EMG_mV"].to_numpy()
wavelet = 'sym4'
level = 10
coeffs_df_Wen_Moderado_Extensor = pywt.wavedec(sig, wavelet, level=level)

# Número total de muestras
N = len(sig)

# Calcular umbrales adaptativos por nivel (D10, D9, ..., D1)
umbrales_df_Wen_Moderado_Extensor = []
for j in range(1, level + 1):
    detail_coeffs = coeffs_df_Wen_Moderado_Extensor[-j]  # D1 está al final, D10 al inicio
    sigma = np.median(np.abs(detail_coeffs)) / 0.6745
    lambda_j = (sigma * np.sqrt(2 * np.log(N))) / np.log(j + 1)
    umbrales_df_Wen_Moderado_Extensor.insert(0, lambda_j)  # orden: D10 → D1

# Función de umbralización mejorada (la misma que ya definiste antes)

# Aplicar umbral mejorado a cada nivel (y graficar coeficientes)
coeffs_filtrados = [coeffs_df_Wen_Moderado_Extensor[0]]  # mantener A10

for i, c in enumerate(pywt.wavedec(sig, wavelet, level=level)):
    plt.figure()
    plt.plot(c)
    plt.title(f"Wen Moderado Extensor - Coeficientes del nivel {i} - {'A' if i==0 else 'D'+str(len(coeffs_filtrados)-i)}")

# Tiempo de TRÍCEPS  para df_Wen_Moderado_Extensor
t = df_Wen_Moderado_Extensor["Tiempo"].to_numpy()

# Aplicar función de umbralización mejorada a cada nivel
coeffs_filtrados = [coeffs_df_Wen_Moderado_Extensor[0]]  # mantener A10

for i in range(1, level + 1):  # i = 1 → D10, ..., i = 10 → D1
    d = coeffs_df_Wen_Moderado_Extensor[i]
    lmbda = umbrales_df_Wen_Moderado_Extensor[i - 1]
    d_filtrado = funcion_umbral_mejorada(d, lmbda)
    coeffs_filtrados.append(d_filtrado)

# Reconstrucción de la señal filtrada
sig_filtrada = pywt.waverec(coeffs_filtrados, wavelet)

# Gráfico comparativo
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(t[:len(sig)], sig, color='blue')
plt.title('Wen Moderado Extensor - Señal EMG Original')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], color='green')
plt.title('Wen Moderado Extensor - Señal EMG Filtrada (Umbral Mejorado)')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(t[:len(sig)], sig, label='Original', alpha=0.7)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], label='Filtrada', alpha=0.7)
plt.title('Wen Moderado Extensor - Superposición')
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# Wen : df_Wen_Intenso_Extensor
sig = df_Wen_Intenso_Extensor["EMG_mV"].to_numpy()
wavelet = 'sym4'
level = 10
coeffs_df_Wen_Intenso_Extensor = pywt.wavedec(sig, wavelet, level=level)

# Número total de muestras
N = len(sig)

# Calcular umbrales adaptativos por nivel (D10, D9, ..., D1)
umbrales_df_Wen_Intenso_Extensor = []
for j in range(1, level + 1):
    detail_coeffs = coeffs_df_Wen_Intenso_Extensor[-j]  # D1 está al final, D10 al inicio
    sigma = np.median(np.abs(detail_coeffs)) / 0.6745
    lambda_j = (sigma * np.sqrt(2 * np.log(N))) / np.log(j + 1)
    umbrales_df_Wen_Intenso_Extensor.insert(0, lambda_j)  # orden: D10 → D1

# Función de umbralización mejorada (la misma que ya definiste antes)

# Aplicar umbral mejorado a cada nivel (y graficar coeficientes)
coeffs_filtrados = [coeffs_df_Wen_Intenso_Extensor[0]]  # mantener A10

for i, c in enumerate(pywt.wavedec(sig, wavelet, level=level)):
    plt.figure()
    plt.plot(c)
    plt.title(f"Wen Intenso Extensor - Coeficientes del nivel {i} - {'A' if i==0 else 'D'+str(len(coeffs_filtrados)-i)}")

# Tiempo de TRÍCEPS
t = df_Wen_Intenso_Extensor["Tiempo"].to_numpy()

# Aplicar función de umbralización mejorada a cada nivel
coeffs_filtrados = [coeffs_df_Wen_Intenso_Extensor[0]]  # mantener A10

for i in range(1, level + 1):  # i = 1 → D10, ..., i = 10 → D1
    d = coeffs_df_Wen_Intenso_Extensor[i]
    lmbda = umbrales_df_Wen_Intenso_Extensor[i - 1]
    d_filtrado = funcion_umbral_mejorada(d, lmbda)
    coeffs_filtrados.append(d_filtrado)

# Reconstrucción de la señal filtrada
sig_filtrada = pywt.waverec(coeffs_filtrados, wavelet)

# Gráfico comparativo
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(t[:len(sig)], sig, color='blue')
plt.title('Wen Intenso Extensor - Señal EMG Original')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], color='green')
plt.title('Wen Intenso Extensor - Señal EMG Filtrada (Umbral Mejorado)')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(t[:len(sig)], sig, label='Original', alpha=0.7)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], label='Filtrada', alpha=0.7)
plt.title('Wen Intenso Extensor - Superposición')
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

#fLEXOR

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np


# Función para convertir de ADC a milivoltios (mV)
def ADCtomV(ADC, n=10, VCC=3.3):
    volts = (((ADC / (2 ** n)) - (1 / 2)) * VCC) / 1009
    return volts * 1000  # Convertir a milivoltios

# Columnas
columnas = ["Tiempo", "0.1", "0.2", "0.3", "0.4", "EMG"]
fs = 1000

# Procesamiento general
def procesar_emg_csv(nombre_archivo):
    df = pd.read_csv(nombre_archivo, header=None, names=columnas)
    df = df[pd.to_numeric(df["EMG"], errors="coerce").notnull()].copy()
    df["EMG"] = pd.to_numeric(df["EMG"], errors="coerce")
    df["Tiempo"] = np.arange(len(df)) / fs
    df["EMG_mV"] = ADCtomV(df["EMG"])
    return df

# Procesar cada señal
df_Wen_Reposo_Flexor = procesar_emg_csv("Wendy_Reposo_Flexor.csv")
df_Wen_Moderado_Flexor = procesar_emg_csv("Wendy_Moderado_Flexor.csv")
df_Wen_Intenso_Flexor = procesar_emg_csv("Wendy_Intensivo_Flexor.csv")

# Mostrar como en la imagen
print("Wen_Reposo_Flexor:")
print(df_Wen_Reposo_Flexor[["Tiempo", "0.1", "0.2", "0.3", "0.4", "EMG", "EMG_mV"]].head(), "\n")

print("Wen_Moderado_Flexor:")
print(df_Wen_Moderado_Flexor[["Tiempo", "0.1", "0.2", "0.3", "0.4", "EMG", "EMG_mV"]].head(), "\n")

print("Wen_Intenso_Flexor:")
print(df_Wen_Intenso_Flexor[["Tiempo", "0.1", "0.2", "0.3", "0.4", "EMG", "EMG_mV"]].head())

df_Wen_Reposo_Flexor.plot(x="Tiempo", y="EMG")
df_Wen_Moderado_Flexor.plot(x="Tiempo", y="EMG")
df_Wen_Intenso_Flexor.plot(x="Tiempo", y="EMG")

# Señal y descomposición DWT ya definidas para extensor Wen reposo
sig = df_Wen_Reposo_Flexor["EMG"].to_numpy()
wavelet = 'sym4'
level = 10
coeffs_df_Wen_Reposo_Flexor = pywt.wavedec(sig, wavelet, level=level)

# Número total de muestras
N = len(sig)

# Calcular umbrales adaptativos por nivel (D10, D9, ..., D1)
umbrales_df_Wen_Reposo_Flexor= []
for j in range(1, level + 1):
    detail_coeffs = coeffs_df_Wen_Reposo_Flexor[-j]  # D1 está al final, D10 al inicio de los detalles
    sigma = np.median(np.abs(detail_coeffs)) / 0.6745
    lambda_j = (sigma * np.sqrt(2 * np.log(N))) / np.log(j + 1)
    umbrales_df_Wen_Reposo_Flexor.insert(0, lambda_j)  # para mantener el orden: D10 → D1

# 4. Función de umbralización mejorada (artículo, ecuación 8)

def funcion_umbral_mejorada(x, lmbda, mu=0.91, delta=0.01):
    x = np.asarray(x)
    res = np.zeros_like(x)

    # |x| <= λ → 0
    mask_zero = np.abs(x) <= lmbda
    res[mask_zero] = 0

    # x > λ
    mask_pos = x > lmbda
    x_pos = x[mask_pos]
    term1 = np.exp(delta * (lmbda - x_pos)) * (lmbda**2) / np.sqrt(x_pos**2 - 2 * x_pos * np.exp(mu) * (np.exp(lmbda - x_pos) - 1))
    term2 = (1 - np.exp(delta * (lmbda - x_pos))) * (lmbda**2) / (x_pos * np.exp(delta * (x_pos - lmbda)))
    res[mask_pos] = x_pos - (term1 + term2)

    # x < -λ
    mask_neg = x < -lmbda
    x_neg = x[mask_neg]
    term1 = np.exp(delta * (lmbda + x_neg)) * (lmbda**2) / np.sqrt(x_neg**2 + 2 * x_neg * np.exp(mu) * (np.exp(lmbda + x_neg) - 1))
    term2 = (1 - np.exp(delta * (lmbda + x_neg))) * (lmbda**2) / (-x_neg * np.exp(-delta * (x_neg + lmbda)))
    res[mask_neg] = x_neg + (term1 - term2)

    return res

# -------------------------------
# 5. Aplicar umbral mejorado a cada nivel de detalle

coeffs_filtrados = [coeffs_df_Wen_Reposo_Flexor[0]]  # mantener aproximación A10

for i, c in enumerate(pywt.wavedec(sig, wavelet, level=level)):
    plt.figure()
    plt.plot(c)
    plt.title(f"Coeficientes del nivel {i} - {'A' if i==0 else 'D'+str(len(coeffs_filtrados)-i)}")

t = df_Wen_Reposo_Flexor["Tiempo"].to_numpy()
for i in range(1, level + 1):  # i = 1 → D10, ..., i = 10 → D1
    d = coeffs_df_Wen_Reposo_Flexor[i]
    lmbda = umbrales_df_Wen_Reposo_Flexor[i - 1]
    d_filtrado = funcion_umbral_mejorada(d, lmbda)
    coeffs_filtrados.append(d_filtrado)

# -------------------------------
# 6. Reconstrucción de la señal filtrada
sig_filtrada = pywt.waverec(coeffs_filtrados, wavelet)

# -------------------------------
# 7. Gráfico comparativo
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(t[:len(sig)], sig, color='blue')
plt.title('Wen Reposo Flexor - Señal EMG Original')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], color='green')
plt.title('Wen Reposo Flexor - Señal EMG Filtrada (Umbral Mejorado)')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(t[:len(sig)], sig, label='Original', alpha=0.7)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], label='Filtrada', alpha=0.7)
plt.title('Wen Reposo Flexor - Superposición')
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# Señal y descomposición DWT ya definidas para flexor Wen moderado
sig = df_Wen_Moderado_Flexor["EMG"].to_numpy()
wavelet = 'sym4'
level = 10
coeffs_df_Wen_Moderado_Flexor = pywt.wavedec(sig, wavelet, level=level)

# Número total de muestras
N = len(sig)

# Calcular umbrales adaptativos por nivel (D10, D9, ..., D1)
umbrales_df_Wen_Moderado_Flexor= []
for j in range(1, level + 1):
    detail_coeffs = coeffs_df_Wen_Moderado_Flexor[-j]  # D1 está al final, D10 al inicio de los detalles
    sigma = np.median(np.abs(detail_coeffs)) / 0.6745
    lambda_j = (sigma * np.sqrt(2 * np.log(N))) / np.log(j + 1)
    umbrales_df_Wen_Moderado_Flexor.insert(0, lambda_j)  # para mantener el orden: D10 → D1

# 4. Función de umbralización mejorada (artículo, ecuación 8)

def funcion_umbral_mejorada(x, lmbda, mu=0.91, delta=0.01):
    x = np.asarray(x)
    res = np.zeros_like(x)

    # |x| <= λ → 0
    mask_zero = np.abs(x) <= lmbda
    res[mask_zero] = 0

    # x > λ
    mask_pos = x > lmbda
    x_pos = x[mask_pos]
    term1 = np.exp(delta * (lmbda - x_pos)) * (lmbda**2) / np.sqrt(x_pos**2 - 2 * x_pos * np.exp(mu) * (np.exp(lmbda - x_pos) - 1))
    term2 = (1 - np.exp(delta * (lmbda - x_pos))) * (lmbda**2) / (x_pos * np.exp(delta * (x_pos - lmbda)))
    res[mask_pos] = x_pos - (term1 + term2)

    # x < -λ
    mask_neg = x < -lmbda
    x_neg = x[mask_neg]
    term1 = np.exp(delta * (lmbda + x_neg)) * (lmbda**2) / np.sqrt(x_neg**2 + 2 * x_neg * np.exp(mu) * (np.exp(lmbda + x_neg) - 1))
    term2 = (1 - np.exp(delta * (lmbda + x_neg))) * (lmbda**2) / (-x_neg * np.exp(-delta * (x_neg + lmbda)))
    res[mask_neg] = x_neg + (term1 - term2)

    return res

# -------------------------------
# 5. Aplicar umbral mejorado a cada nivel de detalle

coeffs_filtrados = [coeffs_df_Wen_Moderado_Flexor[0]]  # mantener aproximación A10

for i, c in enumerate(pywt.wavedec(sig, wavelet, level=level)):
    plt.figure()
    plt.plot(c)
    plt.title(f"Coeficientes del nivel {i} - {'A' if i==0 else 'D'+str(len(coeffs_filtrados)-i)}")

t = df_Wen_Moderado_Flexor["Tiempo"].to_numpy()
for i in range(1, level + 1):  # i = 1 → D10, ..., i = 10 → D1
    d = coeffs_df_Wen_Moderado_Flexor[i]
    lmbda = umbrales_df_Wen_Moderado_Flexor[i - 1]
    d_filtrado = funcion_umbral_mejorada(d, lmbda)
    coeffs_filtrados.append(d_filtrado)

# -------------------------------
# 6. Reconstrucción de la señal filtrada
sig_filtrada = pywt.waverec(coeffs_filtrados, wavelet)

# -------------------------------
# 7. Gráfico comparativo
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(t[:len(sig)], sig, color='blue')
plt.title('Wen Moderado Flexor - Señal EMG Original')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], color='green')
plt.title('Wen Moderado Flexor - Señal EMG Filtrada (Umbral Mejorado)')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(t[:len(sig)], sig, label='Original', alpha=0.7)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], label='Filtrada', alpha=0.7)
plt.title('Wen Moderado Flexor - Superposición')
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# Señal y descomposición DWT ya definidas para flexor Wen moderado
sig = df_Wen_Intenso_Flexor["EMG"].to_numpy()
wavelet = 'sym4'
level = 10
coeffs_df_Wen_Intenso_Flexor = pywt.wavedec(sig, wavelet, level=level)

# Número total de muestras
N = len(sig)

# Calcular umbrales adaptativos por nivel (D10, D9, ..., D1)
umbrales_df_Wen_Intenso_Flexor= []
for j in range(1, level + 1):
    detail_coeffs = coeffs_df_Wen_Intenso_Flexor[-j]  # D1 está al final, D10 al inicio de los detalles
    sigma = np.median(np.abs(detail_coeffs)) / 0.6745
    lambda_j = (sigma * np.sqrt(2 * np.log(N))) / np.log(j + 1)
    umbrales_df_Wen_Intenso_Flexor.insert(0, lambda_j)  # para mantener el orden: D10 → D1

# 4. Función de umbralización mejorada (artículo, ecuación 8)

def funcion_umbral_mejorada(x, lmbda, mu=0.91, delta=0.01):
    x = np.asarray(x)
    res = np.zeros_like(x)

    # |x| <= λ → 0
    mask_zero = np.abs(x) <= lmbda
    res[mask_zero] = 0

    # x > λ
    mask_pos = x > lmbda
    x_pos = x[mask_pos]
    term1 = np.exp(delta * (lmbda - x_pos)) * (lmbda**2) / np.sqrt(x_pos**2 - 2 * x_pos * np.exp(mu) * (np.exp(lmbda - x_pos) - 1))
    term2 = (1 - np.exp(delta * (lmbda - x_pos))) * (lmbda**2) / (x_pos * np.exp(delta * (x_pos - lmbda)))
    res[mask_pos] = x_pos - (term1 + term2)

    # x < -λ
    mask_neg = x < -lmbda
    x_neg = x[mask_neg]
    term1 = np.exp(delta * (lmbda + x_neg)) * (lmbda**2) / np.sqrt(x_neg**2 + 2 * x_neg * np.exp(mu) * (np.exp(lmbda + x_neg) - 1))
    term2 = (1 - np.exp(delta * (lmbda + x_neg))) * (lmbda**2) / (-x_neg * np.exp(-delta * (x_neg + lmbda)))
    res[mask_neg] = x_neg + (term1 - term2)

    return res

# -------------------------------
# 5. Aplicar umbral mejorado a cada nivel de detalle

coeffs_filtrados = [coeffs_df_Wen_Intenso_Flexor[0]]  # mantener aproximación A10

for i, c in enumerate(pywt.wavedec(sig, wavelet, level=level)):
    plt.figure()
    plt.plot(c)
    plt.title(f"Coeficientes del nivel {i} - {'A' if i==0 else 'D'+str(len(coeffs_filtrados)-i)}")

t = df_Wen_Intenso_Flexor["Tiempo"].to_numpy()
for i in range(1, level + 1):  # i = 1 → D10, ..., i = 10 → D1
    d = coeffs_df_Wen_Intenso_Flexor[i]
    lmbda = umbrales_df_Wen_Intenso_Flexor[i - 1]
    d_filtrado = funcion_umbral_mejorada(d, lmbda)
    coeffs_filtrados.append(d_filtrado)

# -------------------------------
# 6. Reconstrucción de la señal filtrada
sig_filtrada = pywt.waverec(coeffs_filtrados, wavelet)

# -------------------------------
# 7. Gráfico comparativo
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(t[:len(sig)], sig, color='blue')
plt.title('Wen Intenso Flexor - Señal EMG Original')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], color='green')
plt.title('Wen Intenso Flexor - Señal EMG Filtrada (Umbral Mejorado)')
plt.ylabel('Amplitud')
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(t[:len(sig)], sig, label='Original', alpha=0.7)
plt.plot(t[:len(sig_filtrada)], sig_filtrada[:len(t)], label='Filtrada', alpha=0.7)
plt.title('Wen Intenso Flexor - Superposición')
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()